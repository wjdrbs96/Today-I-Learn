# `아이템26 : 로 타입은 사용하지 말라`

`로 타입이란 제너릭 타입에서 타입 매게변수를 전혀 사용하지 않을 때를 말합니다.`

```
private final Collection stamps = "...";
```

이 코드를 사용하면 실수로 도장(Stamp) 대신 동전(Coin)을 넣어도 아무 오류 없이 컴파일되고 실행됩니다. (경고 메세지 저오는 던져줄 것입니다.)

```
for (Iterator i = stamps.iterator(); i.hasNext(); ) {
    Stamp stamp = (Stamp) i.next();  
    stamp.cancel();
}
```

이러면 컴파일 때 에러를 잡지 못하고 런타임 때 에러가 발생하게 됩니다. 따라서 나중에 문제를 해결하기가 쉽지 않을 수 있습니다.

<br>

제너릭을 활용하면 아래와 같이 사용할 수 있습니다.

```
private final Collection<Stamp> stamps = "...";
```

이렇게 선언하면 컴파일러는 stamps에는 Stamp의 인스턴스만 넣어야 함을 컴파일러가 인지하게 됩니다.

`타입 매게변수가 없는 제너릭 타입을 쓰는 걸 언어 차원에서 막아 놓지는 않았지만 절대로 써서는 안 됩니다.`

<br>

## `규칙의 예외 2가지`

- `class 리터럴에는 로 타입을 써야 한다.`
    - 자바 명세는 class 리터럴에 매게변수화 타입을 사용하지 못하게 했습니다. 예를들어 `List.class, String[].class, int.class`는 허용하고 List<String>.class와 List<?>.class는 허용하지 않는다.

- `instanceof` 연산자와 관련이 있다. 아래의 코드는 제너릭 타입에 instanceof를 사용하는 올바른 예입니다. 

```
if (o instanceof Set) {        // 로 타입
    Set<?> s = (Set<?>) o;     // 와일드카드 타입
}
```

<br>

## 같이 얘기하면 좋을 것

- `Set<Object>와 Set<?> 의 차이는 무엇일까요?` Object는 어떤 타입의 객체도 저장할 수 있는 매게변수화 타입입니다. 

- 제네릭타입<?> : 제한없음 = 타입 파라미터를 대치하는 구체적인 타입으로 모든 클래스나 인터페이스 타입이 올 수 있습니다.
    - `구체적인 타입`이란 상속이나 인터페이스를 구현하는 클래스 이런 뜻? ?  

- 제네릭에 문자를 사용하는거 예를들어 Key = > K, Value => V 이런거 잘 지키는 것에 대해 얘기해보기

<br>

## 궁금한 점

- 핵심 정리 => `Set<?>는 모종의 타입 객체만 저장할 수 있는 와일드카드 타입이다.` ex) 모종: 어떠한 종류
- Set<?> 에서 ? 타입에 대해서 토론해보기




