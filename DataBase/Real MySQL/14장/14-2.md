# `14.2 물리 모델링`

물리 모델링에서는 논리 모델링을 통해 나온 결과를 RDBMS의 특성에 맞게 변환하는 작업을 수행합니다.

- 논리 모델에서 신경 쓰지 않았던 M:M 관계와 같이 RDBMS에 구현할 수 없는 구조를 해소하는 작업
- 프라이머리 키의 컬럼 순서 선정
- 컬럼의 이름 부여
- 커럴므이 데이터 타입 선정
- 조회 성능을 위한 반정규화

<br> <br>

## `14.2.1 프라이머리 키 선택`

논리 모델링에서 식별자는 최대한 간결하면서도 엔티티의 레코드를 대표할 수 있는 어트리뷰트의 집합으로 선정했습니다. 하지만 논리 모델링에서 선정한 식별자가 항상 물리 모델의 프라이머리 키가 되는 것은 아닙니다.
또한 논리 모델에서는 식별자를 구성하는 각 속성의 순서가 크게 관심 대상이 아니지만 `물리 모델에서는 프라이머리 키를 구성하는 컬럼의 순서가 매우 중요합니다.`

![스크린샷 2021-08-12 오후 3 44 06](https://user-images.githubusercontent.com/45676906/129150151-579ab850-66de-44e1-8924-4f53b7f29e83.png)

위의 모델을 주면 관계의 제일 마지막에 있는 주문 내역 테이블은 4개의 컬럼으로 프라이머리 키가 구성되어 있습니다. 테이블의 프라이머리 키를 복합 컬럼으로 구성할 때는 너무 많은 컬럼이 프라이머리 키로 참여하지 않게 적절히 끊어줄 필요가 있습니다.
자식 테이블 중에서도 관계를 많이 가지는 중요 테이블에서 부모와의 프라이머리 키 상속을 끊고, 새로운 프라이머리 키를 갖게 해주는 것이 좋습니다.

<br> <br>

## `14.2.2 데이터 타입 선정`

물리 모델링에서 컬럼의 데이터 타입은 가능한 한 최소 단위의 타입을 부여해야 합니다. 가끔 `VARCHAR(10)`이나 `VARCHAR(100)` 모두 필요한 만큼의 공간을 사용하는 것인데, 왜 `VARCHAR(100)`을 사용해야 하는가? 라는 질문이 있습니다.(큰 차이 없을 줄 알았는데!)

이것은 `임시테이블`과도 연관이 있는데요. 테이블의 컬럼 `first_name` 이라는 컬럼이 `VARCHAR(512` 라고 가정해보겠습니다. 실제 메모리 테이블에서 first_name 컬럼이 차지하는 공간은 512 * 3(UTF8 기준) 바이트가 될 것입니다. 실제 first_name 컬럼의 값이 1글자이든 2글자이든 관계없이, 테이블에 정의된 크기만큼 메모리 테이블에서 공간을 차지한다는 특징이 있습니다.
이러한 임시 테이블의 저장 방식 때문에 SELECT 하는 컬럼은 최소화하고(특히 BLOB 이나 TEXT 컬럼은 배제하는 것이 좋음) 컬럼의 데이터 타입 선정도 가능한 작게 해주는 것이 좋습니다.

테이블의 레코드 건수가 많지 않다면 어떤 컬럼이 프라이머리 키로 선정되고, 각 컬럼의 타입이 어떻게 설정되든 큰 차이는 없습니다. 하지만 테이블의 레코드 건수가 많아지면 데이터 타입을 한 바이라도 크게 설정하면 많은 차이를 만들어 낼 수 있습니다.

<br> <br>

### `데이터의 타입`

어떤 데이터를 관리하기 위해 사용할 수 있는 데이터 타입은 여러 가지가 있을 수 있습니다. 만약 각 데이터 타입별로 차지하는 공간이나 성격을 잘 모른다면 저장하려는 데이터 성격별로 그대로 타입을 선정하는 것이 가장 좋습니다.
ex) 숫자는 숫자타입, 날짜는 문자가 아니라 날짜 타입

<br> <br>

### `컬럼의 길이`

컬럼의 데이터 타입이 결정되면 다음은 각 데이터 타입별로 길이를 설정하는 것입니다. 

<br> <br>

### `NULL과 NOT NULL`

- InnoDB 스트리지 엔진
  - InnoDB 테이블에서는 컬럼이 NULL 이면 고정된 타입, 가변 타입(VARCHAR 등) 모두 NULL이 저장되는 컬럼은 전혀 디스크 공간을 사용하지 않습니다. 즉, InnoDB는 NULL을 저장함으로써 실제 디스크의 공간 절약을 할 수 있습니다.
  
<br>

NULL이 저장될 수 있는 컬럼에 대해 IN 형태의 조건을 사용하면 MySQL은 상상하지 못했던 이상한 비교 작업을 내부적으로 하게 됩니다. 
하지만 NULL과 NOT NULL은 디스크 공간 절약의 문제가 아니라 옵티마이저가 얼마나 쿼리를 더 최적화할 수 있게 환경을 만들어줄 것이느냐의 관점에서 고려 해야 합니다.

<br> <br>

## `14.2.3 반정규화`

모델의 정규화는 최대한 중복되는 컬럼을 제거하므로 INSERT와 UPDATE와 같은 데이터 변경 작업에 최적화된 모델을 만들어냅니다. 하지만 모델을 정규화할수록 SELECT 쿼리에서 필요한 테이블의 수 뿐만 아니라 GROUP BY 쿼리 자체의 개수도 증가합니다. (JOIN이 늘어남!)

현재 MySQL 5.x 버전은 조인이 상당히 최적화돼 있어서 크게 문제되지 않지만 많은 레코드를 GROUP BY 하는 쿼리는 실시간으로 실행하기에는 부담스러울 수도 있습니다. `GROUP BY나 COUNT(*)와 같이 많은 레코드를 대상으로 하는 작업을 빠르게 조회하기 위해 미리 건수를 집계해서 별도의 테이블이나 컬럼을 저장해두는 것을 반정규화` 라고 합니다.(오.. 항상 고민했던 것인데)

반정규화에서 주의해야 할 것은 어떻게 반정규화된 컬럼이나 테이블을 유지할 것인가입니다. 일반적으로 반정규화된 컬럼은 실시간으로 업데이트하는 방식으로 유지하는데, 이는 INSERT, UPDATE, DELETE 작업을 할 때 또 다른 쿼리를 필요로 하므로 변경 작업의 부하가 커지고 잠금의 경합도 많이 일으킵니다. 
반정규화된 컬럼의 값을 유지하려면 최대한 모아서 배치 형태로 실행하거나 백그라운드 작업으로 처리하는 것이 좋습니다.

반정규화의 종류와 방법을 살펴보겠습니다. 

<br> 

### `컬럼 복사`

