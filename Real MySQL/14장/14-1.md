# `데이터 모델링`

일반적으로 논리 설계는 한글로 테이블이나 컬럼명을 작성하고, 물리 설계는 DBMS에서 사용할 수 있는 영문으로 작성합니다.
하지만 논리 모델링이나 물리 모델링의 구분 기준은 테이블이나 컬럼의 이름이 영어냐 한글이냐가 아니라 모델에 표현하려는 것이 `업무냐 시스템`이느냐 입니다.

- 논리 모델링: 데이터베이스 종류와 관계 없이 업무를 분석하고 그에 대한 데이터 집합과 그 집합 간의 관계를 중점적으로 표현하는 것
- 물리 모델링: 논리 모델링의 산출물을 시스템으로 어떻게 표현할지를 고려하는 것

<br> <br> 

# `14.1 논리 모델링`

- 엔티티의 범위 확정
- 필수 속성 정의
- 각 엔티티의 의미상 식별자를 선정
- 각 엔티티 간의 관계를 최대한 간결히 표헌

ERD의 생명은 `가독성`!! 그리고 위에서 말한 것들을 모두 표현하는 것이 `가장 중요` 합니다.

<br> <Br>

## `14.1.1 모델링 용어`

![스크린샷 2021-08-11 오후 5 29 45](https://user-images.githubusercontent.com/45676906/128996470-3385bcab-d8fe-4678-854a-aa65b01b7890.png)

- 주제 영역: 관리 용이성이나 가독성을 위해 엔티티를 업무 분류별로 나눠서 그룹핑을 하는데, 이를 주제 영역이라고 합니다. 
- 엔티티가 200개라 하더라도 직접적인 연관성을 가지는 엔티티는 대부분 4~5개가 일반적

- 엔티티와 테이블 하나의 논리 모델은, 관계형 데이터베이스를 위한 물리 모델로 진화할 수 있고 객체지향 데이터베이스를 위한 물리 모델로 변화할 수도 있습니다.

<br> <br>

## `14.1.2 용어집`

데이터를 모델링할 때 각 객체가 어디서부터 어디까지를 포함할 것인지를 명확히 하는 것이 매우 중요!
그래야 해당 엔티티의 속성이나 식별자를 선장할 수 있고 이름도 정할 수 있음!

- ERD를 그리기 이전 또는 이후에 모든 주요 단어에 대해 명확히 그 범위를 제한하는 작업을 한 번씩 진행하길 적극 권장함
- 특히나 주요 용어에 대해서는 모든 가능한 경우의 관련 단어를 나열하고, 그 의미를 포함할지 뺄지를 체크

<br> <br>


## `14.1.3 엔티티`

- 엔티티는 객체지향 개발 언어의 클라스와 동급의 의미
- 엔티티와 테이블은 항상 1:1 관계로 구현되는 것은 아님
- `해당 용어가 의미하는 범위가 어디까지인가를 명확히 하고 그에 걸맞는 이름을 부여하는 것이 중요!`

<br>

![스크린샷 2021-08-11 오후 5 39 50](https://user-images.githubusercontent.com/45676906/128997996-e5c8012a-6f90-477b-9e92-45517d4f1e24.png)

식별자속성 부분에 엔티티의 `식별자(프라이머리 키)`를 구성하는 속성을 작성하고, 하단 영역에는 식별자가 아닌 일반 속성을 나열합니다.

<br>

![스크린샷 2021-08-11 오후 5 41 23](https://user-images.githubusercontent.com/45676906/128998217-42f350b0-ac70-4b7b-9aa8-b6795d5d52ac.png)

- 키 엔티티 간의 관계로 만들어지는 엔티티를 `액션 엔티티`라고 표현
- 회원(키 엔티티), 친구(회원 엔티티)

<br>

![스크린샷 2021-08-11 오후 5 43 40](https://user-images.githubusercontent.com/45676906/128998489-5b1d7d37-acf4-4c10-8513-7e2d3b2ee3f1.png)

위의 그림은 `고객`과 `상품`의 관계에서 발생한 `구매`라는 엔티티의 관계를 보여주는 `ERD` 입니다.
(다대다)

- 구매 엔티티는 식별자로 `고객 아이디 + 상품 코드 + 구매 일련번호`를 가지는데 이렇게 속셩의 조합을 `본질 식별자`라고 합니다.

<br>

### `엔티티의 작명`

- 엔티티 이름에 수식어가 있다면 주의해서 검토하고 필요하다면 통합하는 것이 좋습니다. ex) 상품(O), 직원용상품(X), 고객용상품(X) 등등

<br> <br>

## `속성`

- 추출 컬럼: 하나의 엔티티나 다른 엔티티의 속성으로부터 계산된 값 ex) 댓글 수, 게시글 수
- 정규화는 중복된 데이터를 제거하기 위해 진행하지만 추출 컬럼은 반대로 데이터의 중복을 더 만들어냄

<br>

### `어트리뷰트의 원자성`

- 속성은 반드시 독자적인 성징을 가지는 하나의 값만을 저장해야 한다.
- 최소 단위를 잘 정하는 것이 중요 ex) 주소와 같은 것
- 취미 같은거 ,를 구분해서 한꺼번에 저장하는건 기존 조건에 위배되는 모델링 방법

<br> <br>

## `14.1.5 식별자(프라이머리 키)`

프라이머리 키 또는 식별자는 하나의 엔티티에서 개별 레코드를 식별할 수 있는 어트리뷰트의 조합을 의미합니다.


<br> <br>

## `14.1.6 관계(릴레이션)`

ERD는 엔티티(Entity)와 관계(Realation)의 다이어그램 입니다. 관계 선이 없고 엔티티만 표시된 다이어그램은 ERD라고 볼 수 없습니다. 

- 엔티티가 독립적인 데이터의 집합이라면 관계는 각 데이터 간의 `상호작용`을 표현하는 것입니다.
- 우리가 개발하는 애플리케이션은 독립적인 데이터 집합을 저장하고 삭제하기도 하지만 대부분 이런 엔티티간의 `상호작용`을 처리하는 역할을 하는 것입니다.
- 엔티티 뿐만 아니라 릴레이션도 매우 중요함


<br> <br>

## `14.1.9 모델 정규화`

![스크린샷 2021-08-12 오후 1 25 21](https://user-images.githubusercontent.com/45676906/129138119-8ca68195-02be-4de0-be2d-1d23ae0973f5.png)

위의 그림은 `정규화 되지 않은` 모델인데요. 위의 모델의 문제점은 아래와 같습니다.

- `우편번호와 주소`: 하나의 속성에 2개의 복합된 정보를 저장하고 있습니다.
- `친구회들의회원번호`: 여러 개의 정보를 하나의 속성에 담고 있음
- `주문상품번호`: 회원 엔티티와 전혀 관계없는 정보

<br> <br>

### `정규화를 하는 이유는?`

정규화의 가장 큰 목적은 모델에서 중복된 데이터를 최소화하고 일반적으로 납들될 수 있는 모델로 만드는 것입니다.
즉, `각 어트리뷰트가 적절한 엔티티에 배치되고 각 어트리뷰트가 중복된 데이터를 갖지 않게 하는 것이 가장 큰 목적` 입니다.

논리 모델링에서 진행하는 정규화는 데이터의 저장 비용을 최소화하는 역할을 담당하고, 물리 모델링 반정규화는 데이터를 읽어 오는 비용을 최소화하는 역할을 합니다.

데이터를 저장하는 작업과 읽어 오는 작업이 똑같이 중요하듯이 정규화해서 데이터의 중복을 제거하는 작업과 반정규화를 통해 데이터를 효율적으로 읽어올 수 있게 하는 것 둘 다 필수적으로 필요한 과정입니다.
(정규화를 너무 잘해놓으면 데이터를 가져올 때 조인이 많이 필요한 거 같고 정규화를 덜하면 데이터 중복이 늘어나는 거 같고..)

`즉, 정규화를 수행하지 않으면 데이터 중복이 많아지고, 그로 인해 하나의 트랜잭션에서 중복된 데이터를 모두 변경해야 하므로 성능이 떨어질 수 밖에 없는 것` 입니다.

<br> <br>

## `제 1정규화(No Repeating Group)`

`모든 속성은 반드시 하나의 값을 가져야 한다`라는 것이 제 1정규화의 검증 기준입니다. 

![스크린샷 2021-08-12 오후 1 40 10](https://user-images.githubusercontent.com/45676906/129139103-5a353814-1f4d-4ec1-91aa-81f490cf50e0.png)

위와 같이 `중복된 값을 가지는 엔티티`는 제 1정규화를 위반한 것인데요.

<br>

![스크린샷 2021-08-12 오후 1 40 23](https://user-images.githubusercontent.com/45676906/129139118-3be607af-2367-4046-b4d1-b8be4103d8fa.png)

제 1정규화를 위반한 엔티티를 위와 같이 분리해서 저장할 수 있습니다. 회원 엔티티에서 자택 주소나 회사 주소를 동시에 검색하지 않고 더는 다른 주소가 추가되지 않는다면 위와 같이 하여도 무방할 것입니다. 
하지만 항상 서비스에서는 기능 추가와 예상치 못하게 변경해야 할 일이 많기 때문에 아래와 같이 독립 시키는 것이 좋습니다.

![스크린샷 2021-08-12 오후 1 43 43](https://user-images.githubusercontent.com/45676906/129139333-af0075f3-6d19-4057-9537-3e06e43fce65.png)

정리하자면 `하나의 어트리뷰트에 여러 개의 값을 저장하거나 엔티티에서 똑같은 성격의 어트리뷰트가 여러 번 나열되는 것은 일반적으로 제 1정규화를 위반한 것`입니다.

<br> <br>

## `제 2정규화(Whole Key Dependent)`

제 2정규화의 요건은 `식별자 일부에 종속되는 어트리뷰트는 제거해야 한다` 입니다. 어떤 엔티티의 식별자를 구성하는 어트리뷰트가 2개일 때 그 엔티티의 모든 어트리뷰트가 식별자에 모두 완전하게 종속적인지를 확인하는 것이 제 2정규화입니다.

![스크린샷 2021-08-12 오후 1 52 00](https://user-images.githubusercontent.com/45676906/129139919-b77a42c4-ef6b-4d61-8807-9c2471b26cdf.png)

친구 엔티티는 두 개의 속성으로 식별자가 구성되어 있습니다. 하지만 `친구 회원명`이라는 어트리뷰트는 식별자를 구성하는 두 개의 어트리뷰트 중에서 `친구회원번호`에만 종속 관계를 가지고, 식별자의 나머지 어트리뷰트인 회원번호와는 어떠한 종속관계도 없다는 사실을 알 수 있습니다. 

이처럼 `식별자의 일부에만 종속 관계를 가지고 있는 어트리뷰트는 제거해야 한다는 것이 제 2정규화`입니다.
`친구 회원명` 어트리뷰트는 원래 있어야 할 회원 엔티티로 옮겨야 합니다. 
즉, 말이 어렵지만 `관련 없는 컬럼은 다 다른 곳으로 이동해야 한다` 정도로 말할 수 있을 거 같습니다.

<br> <br>

## `제 3정규화(Non-Key Indepedent)`

제 3정규화의 검증 규칙은 `식별자 이외의 속성간에 종속 관계가 존재하면 안 된다` 입니다.
식별자가 아닌 모든 어트리뷰트는 식별자에 종속성을 가져야 함과 동시에 식별자가 아닌 모든 어트리뷰트 간에는 어떠한 종속 관계도 없이 모두 독립적이어야 합니다.

![스크린샷 2021-08-12 오후 2 37 14](https://user-images.githubusercontent.com/45676906/129143648-b9303f2c-a7a9-4db2-bfc0-b7317ad1d277.png)

회원 엔티티를 보면 `직업 코드`, `직업명`이 존재하는데요. 직업 코드, 직업 명 모두 회원번호에 종속되기 때문에 제 2정규화에 위배되지 않는다는 것은 알 수 있습니다. 하지만 직업명은 직업 코드에 의존적이라는 것을 알 수 있습니다. 

![스크린샷 2021-08-12 오후 2 42 44](https://user-images.githubusercontent.com/45676906/129144122-0be27853-add8-4883-a953-6966585c2b9a.png)

그래서 위와 같이 엔티티를 분리하는 것이 좋습니다. 